\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[margin=1.1in]{geometry}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{float}

\usepackage{setspace} % increase interline spacing slightly
\setstretch{1.1}

\def \hfillx {\hspace*{-\textwidth} \hfill}

\title{
	Big Data Analytics \\
	Lab 02 - Wikipedia}
\author{
	Damien Rochat, Dorian Magnin, and Nelson Rocha \\
	Master of Science in Engineering \\
	University of Applied Sciences and Arts Western Switzerland}
\date{\today}

\begin{document}
	\maketitle
	
	\section{Results}
	Here is the number of articles where each programming language has been found. Note, the comparison is made by lowercase.

	\begin{table}[H]
		\begin{minipage}{0.5\textwidth}
			\centering

			\begin{tabular}{|l|l|l|}
				\hline
				\textbf{Rank}  & \textbf{Language}  & \textbf{Number of articles} \\ \hline
				1              & JavaScript         & 1'721                       \\ \hline
				2              & C\#                & 707                         \\ \hline
				3              & Java               & 618                         \\ \hline
				4              & CSS                & 400                         \\ \hline
				5              & C++                & 335                         \\ \hline
				6              & Python             & 315                         \\ \hline
				7              & MATLAB             & 307                         \\ \hline
				8              & PHP                & 302                         \\ \hline
				9              & Perl               & 167                         \\ \hline
				10             & Ruby               & 125                         \\ \hline
				11             & Haskell            & 56                          \\ \hline
				12             & Objective-C        & 47                          \\ \hline
				13             & Scala              & 44                          \\ \hline
				14             & Clojure            & 26                          \\ \hline
				15             & Groovy             & 26                          \\ \hline
			\end{tabular}
			\caption{Wikipedia lab ranking}

		\end{minipage}
		\hfillx
		\begin{minipage}{0.5\textwidth}
			\centering

			\begin{tabular}{|l|l|l|}
				\hline
				\textbf{Rank}  & \textbf{Language} \\ \hline
				1              & JavaScript        \\ \hline
				2              & Java              \\ \hline
				3              & Python            \\ \hline
				4              & PHP               \\ \hline
				5              & C\#               \\ \hline
				6              & C++               \\ \hline
				7              & CSS               \\ \hline
				8              & Ruby              \\ \hline
				9              & C                 \\ \hline
				10             & Objective-C       \\ \hline
				11             & Swift             \\ \hline
				12             & Scala             \\ \hline
				13             & Shell             \\ \hline
				14             & Go                \\ \hline
				15             & R                 \\ \hline
				16             & TypeScript        \\ \hline
				17             & PowerShell        \\ \hline
				18             & Perl              \\ \hline
				19             & Haskell           \\ \hline
				20             & Lua               \\ \hline
			\end{tabular}
			\caption{RedMonk top-20 ranking (June 2018)}

		\end{minipage}
	\end{table}

	Except for JavaScript, large winner in both cases, the Wikipedia ranking doesn't match RedMonk one.
	However, the top-5 of the two rankings is almost the same, in different order.

	\pagebreak

	\section{Performances}
	
	\begin{table}[H]
		\centering

		\begin{tabular}{|l|l|l|}
			\hline
			\textbf{Iteration}           & \textbf{Time} \\ \hline
			Naive ranking                & 54'571 ms     \\ \hline
			Ranking using inverted index & 26'538 ms     \\ \hline
			Ranking using reduceByKey    & 23'593 ms     \\ \hline
		\end{tabular}
		\caption{Execution times}
	\end{table}
	
	These are our obtained execution times. \\
	Let's take the \textit{Naive ranking} time as a base, and see how we manage to speed it up.
	
	At the second step we managed to get a speedup of a roughly 50\%.  \\
	This is due to the inverted index use. By providing us with the information of which article contains which language, it spares us the work of parsing all the RDD. \\
    So the results are far quicker to retrieve.
	
	Finally, we achieved a bit more speedup by using the `reduceByKey` instruction. \\
	By reducing before the shuffling, we greatly reduce the amount of data that will be sent through the network. \\
	As we are working on our own machines, the beneficial effects of this change are not very important.
	But if we were using a remote Spark cluster, the improvements would have been far more visible.
	
	Finally, we wondered if there was nothing we could do to improve our execution times in this specific configuration, which is by having all running in a single machine?
	
	We manage to use all the logical cores seen by the underlying JVM, by declaring our context with  
	\begin{verbatim}
	val conf: SparkConf = new SparkConf()
	    .setAppName("wikipediaArticle") 
	    .setMaster(s\"local[\${Runtime.getRuntime.availableProcessors()}]\")
    \end{verbatim}	
	instead of  
	\begin{verbatim}
	val conf: SparkConf = new SparkConf()
	    .setAppName("wikipediaArticle").setMaster(s"local[1]")
	\end{verbatim}
	
	And we got the following execution times:
	
	\begin{table}[H]
		\centering

		\begin{tabular}{|l|l|l|}
			\hline
			\textbf{Iteration}           & \textbf{Time} \\ \hline
			Naive ranking                & 45'991 ms     \\ \hline
			Ranking using inverted index & 25'603 ms     \\ \hline
			Ranking using reduceByKey    & 22'242 ms     \\ \hline
		\end{tabular}
		\caption{Best execution times obtained}
	\end{table}
	

\end{document}
